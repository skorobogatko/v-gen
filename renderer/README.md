# v-gen (renderer)

Полная документация по модулю `renderer` проекта `v-gen`. Этот документ описывает архитектуру, поток данных, формат входного JSON, жизненный цикл рендера, команды запуска, рекомендации по отладке и развёртыванию.

## Обзор

`renderer` — это модуль, который превращает JSON-проект в MP4-видео. Он использует headless-браузер (Puppeteer/Chromium) для отрисовки кадров на HTML5 Canvas (файлы `src/page.html` и `src/page.js`) и `ffmpeg` для упаковки кадров в MP4 и добавления аудио.

Компоненты:

- `src/page.js` — логика рендера внутри страницы: загрузка изображений/видео, построение списка активных объектов (`buildActiveObjects`), анимации, рисование на canvas и экспорт кадра.
- `src/render.js` — сценарий Node (обычно работает с Puppeteer): передаёт JSON в страницу, вызывает рендер для каждого кадра, получает кадры и собирает видео.
- `tools/mix-audio.js` — утилита для смешивания аудиодорожек и подготовки финального аудио для ffmpeg.
- `project.json` — пример проекта, описывающий сцены, объекты, оверлеи, субтитры и аудио.

## Формат входного JSON

Основные секции:

- `project` — общие параметры:

  - `width` (px), `height` (px)
  - `fps` — частота кадров
  - `background` — цвет заднего фона
  - `videoLength` — ожидаемая длина видео (сек)

- `videoTrack` — массив сцен. Каждый элемент сцены содержит:

  - `start`, `end` — времена в секундах
  - `objects` — массив объектов сцены, где каждый объект имеет поля:
    - `type` — `image`, `video`, `text` и т. п.
    - `src` — URL или путь к ресурсу
    - `x`, `y`, `w`, `h` — позиция и размер
    - `z` — порядок по оси Z
    - `animations` — массив анимаций (`zoom`, `move`, `fade`)

- `overlays` — глобальные слои, которые накладываются поверх сцены (логотипы, рамки). Поля: `start`, `end`, `src`, `x`, `y`, `w`, `h`, `opacity`, `z`.

- `subtitles` — массив { start, end, text } для простого рендеринга субтитров.

- `audio` — описание дорожек (файлы, смещения, громкость). `tools/mix-audio.js` умеет объединять дорожки и возвращать готовый audio-file для ffmpeg.

> Замечание: в коде многие времена умножаются на 1000, т. е. `start`/`end` в JSON заданы в секундах, а в рантайме используются миллисекунды.

## Жизненный цикл рендера (data-flow)

1. Node/Puppeteer запускает браузер и открывает `page.html` с подключённым `src/page.js`.
2. Node передаёт сериализованный JSON-проект в страницу (через `page.evaluate` или аналог).
3. На странице начинается подготовка ресурсов:
   - `loadImage(src)` — загружает изображения с CORS и возвращает Image.
   - `loadVideo(src)` — создаёт HTMLVideoElement, устанавливает `crossOrigin`, `muted`, `preload`, ждёт `onloadeddata`/`oncanplaythrough` и возвращает элемент.
4. После загрузки ресурсов начинается рендер по кадрам:
   - Рассчитывается число кадров: `frames = Math.ceil(project.videoLength * fps)`.
   - Для каждого кадра вычисляется текущее время `ms = frameIndex * (1000 / fps)`.
   - Вызывается `window.__renderer.renderFrame(ms)`, который:
     - вызывает `buildActiveObjects(project, ms)`, чтобы получить список объектов, видимых на этом кадре;
     - применяет анимации (`zoom`, `move`, `fade`) и easing-функции;
     - рисует слои на canvas (в правильном Z-порядке), используя `globalAlpha`, `globalCompositeOperation` и др.;
     - возвращает `ImageData`/Blob или делается screenshot элемента canvas.
5. Node получает кадр(ы) и отправляет их в `ffmpeg` (stdin) или сохраняет во временные PNG.
6. После передачи всех кадров ffmpeg кодирует MP4 и, при наличии, добавляет аудио (смешанное через `mix-audio.js`).
7. Результат: MP4-файл в указанном `out`-пути или поток ответа к HTTP-клиенту.

## Детали реализации (важные функции)

- `buildActiveObjects(project, ms)` — преобразует сцены в плоский список объектов с уже вычисленными трансформациями: `scale`, `tx`, `ty`, `a` (alpha). Этот список затем сортируется по `z` и используется для рисования.
- `fadeAlpha(local, durMs, fade)` — возвращает коэффициент прозрачности для объекта с учётом `fade.in` и `fade.out` (секунды → миллисекунды). Используется в композиции (alpha \*= fadeAlpha(...)).
- `loadVideo(src, muted)` — создаёт видео-элемент, ждёт `onloadeddata`/`oncanplaythrough`, ставит временный `play()` для «разогрева» декодера, использует таймаут.

## Запуск

Примерные команды (внутри папки `renderer`):

```bash
cd renderer
npm install

# Прямая команда рендера (если доступен скрипт):
npm run render -- --project project.json --out out.mp4
```

Если у вас есть `server.js` (Express API), запустите как обычно `node server.js` и отправляйте POST-запросы с JSON.

## HTTP API (рекомендация)

Типичная схема: POST `/render` принимает JSON в теле запроса. Сервер:

1. сохраняет временный `project.json`;
2. вызывает CLI-адаптер или `render.js` (через child_process);
3. ждёт завершения и возвращает MP4 как attachment или URL для скачивания.

Советы:

- Ограничьте размер входного JSON и время выполнения;
- Введите очередь задач (Bull, RabbitMQ) и контроль параллелизма;
- Храните временные артефакты не дольше, чем нужно, и очищайте после отправки.

## Отладка и типичные ошибки

- CORS при работе с video/image: ресурсы должны отдавать `Access-Control-Allow-Origin` иначе canvas-рисование и чтение пикселей будет запрещено.
- Черные/пустые кадры: часто вызвано тем, что видео ещё не успело подготавливаться — увеличьте таймаут в `loadVideo` или используйте warm-up (вызов `play()`/`pause()` перед рендером).
- Производительность: при больших разрешениях и FPS рендер очень медленный; для тестов уменьшайте `width/height` и `fps`.
- ffmpeg failing: проверьте входной формат фреймов и правильность опций `-r`, `-s`, `-pix_fmt`.

Дополнительно — проблемы с повторами / дубликатами кадров

- Причина: в старых вариантах кода логика вычисляла целевые времена seek в целых миллисекундах (ms) и/или округляла их, а исходные PTS в видеопотоке выражаются как дробные секунды (например 0.033333...). При этом две близкие опорные точки времени могли попасть на один и тот же исходный кадр или, наоборот, пропустить нужный (эффект "дублей").
- Быстрое диагностическое средство — `ffprobe`: получить список PTS каждого кадра и посмотреть интервалы между кадрами. Пример:

```bash
ffprobe -v quiet -select_streams v:0 -show_frames \
  -show_entries frame=pkt_pts_time,best_effort_timestamp_time -of csv=p=0 /path/to/video.mp4 | head -n 50
```

Если интервалы равномерны (~0.033333 для 30fps) — видео CFR и проблема в округлениях в коде клиента. Если интервалы разны — это VFR и нужно либо нормализовать видео, либо учитывать VFR при seek.

- Принятое быстрое исправление в коде (минимальный, безопасный патч): при вычислении времени для seek теперь используется индекс кадра, а не округлённые миллисекунды. Алгоритм:

  1. timeSec = localMs / 1000 (с плавающей точкой)
  2. frameIndex = Math.round(timeSec \* fps)
  3. target = frameIndex / fps
  4. seek, только если |v.currentTime - target| > (1 / (fps \* 2)) (порог — половина кадра)

  Это уменьшает влияние округлений ms и стабилизирует попадание запросов seek в точные PTS кадра.

- Как ещё можно улучшить стабильность:
  - Делать fps динамическим: читать fps заранее (например, через `ffprobe` на этапе подготовки ресурса) и сохранять его в `project` или метаданных. На стороне браузера прямой надёжной переменной `video.framerate` нет, поэтому предпочтительна подготовка метаданных до рендера.
  - Использовать `requestVideoFrameCallback` / `VideoFrame.timestamp` (если среда поддерживает): это самый точный способ узнать, какой presentationTime у текущего кадра и когда он сменился.
  - При невозможности править код — нормализовать видео в CFR через ffmpeg: `ffmpeg -i in.mp4 -r 30 -c:v libx264 out_cfr30.mp4`.

## Тесты и валидация

- Юнит-тесты для утилитарных функций (`fadeAlpha`, `lerp`, `buildActiveObjects`) можно запускать отдельно (установите Jest или другое средство).
- Интеграционные тесты: реальный короткий проект (3–5 сек) и проверка, что `render` генерирует MP4 и что ffmpeg не возвращает ошибку.

## Расширения и рекомендации

- Поддержка WebGL/Shader-эффектов для ускорения сложных визуальных эффектов.
- Использование OffscreenCanvas для многопоточности (если среда поддерживает).
- В продакшне — отдельные worker-воркеры/контейнеры для рендер задач, чтобы изолировать ресурсоёмкие задачи.

## Что можно сделать дальше

- Добавить `server.js` (Express) и `src/cli.js` (CLI-адаптер) при желании API-интерфейса.
- Добавить `Dockerfile` и `docker-compose.yml` для развёртывания.
